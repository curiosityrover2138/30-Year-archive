1849 B-> Sort it using mod of k, and the indexes divisible by k will go first, then k-1, k-2, etc 
and among them the ones with lesser ones will go first. Use stable_sort for that.
1831B-> Find the maximum continguous sequence of each element in the array and the left and right pointers
for it, that way you can 
1765M-> Just go through all the divisors in O(sqrt(n)) and find the first divisor that will be the answer
1715B-> Greedy with k*b as first and 
1438B-> If any 2 values are same it will always be possible 
1447 B-> If the negative numbers are odd, we just take the minmum value and subtract it from sum twice. 
Else the sum is the answer.
1704B-> Use a greedy strategy starting from first element, if it doesn't fit, change it or else keep it.
1917B-> Second operation is only needed at first instance, as other strings can be reached 
by just the first operation after that. Thus we check the string from the end,

vector<int> nxt(26, n);
    ans[n - 1] = 1;
    nxt[s[n - 1] - 'a'] = n - 1;

    for (int i = n - 2; i >= 0; i--) {
        ans[i] = ans[i + 1] + (nxt[s[i] - 'a'] - i);
        nxt[s[i] - 'a'] = i;
    }

    cout << ans[0] << endl;

And use dp to add the answer for subsequent 
1891B-> almost did it, the only optimization was just doing it if it is minimum encountered thus far.
1731B-> Use mod_inverse using fermat's little theorem for dividing

ull mod_inverse(ull a, ull m) {
    ull result = 1;
    ull exp = m - 2; // Fermat's Little Theorem
    while (exp > 0) {
        if (exp % 2 == 1) {
            result = (result * a) % m;
        }
        a = (a * a) % m;
        exp /= 2;
    }
    return result;
}

void solve() {
    ull n;
    cin >> n;

    ull inv6 = mod_inverse(6, MOD);

    ull ans = ((n * (n + 1) % MOD) * ((2 * n + 1) % MOD) % MOD) * inv6 % MOD;

    ans = (ans * 2) % MOD;

    ans = (ans - (n * (n + 1) / 2) % MOD + MOD) % MOD; // To keep it positive

    ans = (ans * 2022) % MOD;

    cout << ans << endl;

}

1820 B 

1793C Use a 2 pointer approach.

1742 E 

int n, q;
    cin >> n >> q;
    vector<long long> pref;
    pref.push_back(0);
    vector<int> prefmax;
    for(int i = 0; i < n; i++)
    {
        int x;
        cin >> x;
        pref.push_back(pref.back()+x);
        if(i == 0)
        {
            prefmax.push_back(x);
        }
        else
        {
            prefmax.push_back(max(prefmax.back(), x));
        }
    }
    for(int i = 0; i < q; i++)
    {
        int k;
        cin >> k;
        int ind = upper_bound(prefmax.begin(), prefmax.end(), k)-prefmax.begin();
        cout << pref[ind] << " ";
    }
    cout << endl;

    Using binary search and prefix sum

https://codeforces.com/problemset/problem/1881/D
