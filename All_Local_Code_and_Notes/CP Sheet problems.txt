1849 B-> Sort it using mod of k, and the indexes divisible by k will go first, then k-1, k-2, etc 
and among them the ones with lesser ones will go first. Use stable_sort for that.
1831B-> Find the maximum continguous sequence of each element in the array and the left and right pointers
for it, that way you can 
1765M-> Just go through all the divisors in O(sqrt(n)) and find the first divisor that will be the answer
1715B-> Greedy with k*b as first and 
1438B-> If any 2 values are same it will always be possible 
1447 B-> If the negative numbers are odd, we just take the minmum value and subtract it from sum twice. 
Else the sum is the answer.
1704B-> Use a greedy strategy starting from first element, if it doesn't fit, change it or else keep it.