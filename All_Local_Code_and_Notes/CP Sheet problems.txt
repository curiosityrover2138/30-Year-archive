1849 B-> Sort it using mod of k, and the indexes divisible by k will go first, then k-1, k-2, etc 
and among them the ones with lesser ones will go first. Use stable_sort for that.
1831B-> Find the maximum continguous sequence of each element in the array and the left and right pointers
for it, that way you can 
1765M-> Just go through all the divisors in O(sqrt(n)) and find the first divisor that will be the answer
1715B-> Greedy with k*b as first and 
1438B-> If any 2 values are same it will always be possible 
1447 B-> If the negative numbers are odd, we just take the minmum value and subtract it from sum twice. 
Else the sum is the answer.
1704B-> Use a greedy strategy starting from first element, if it doesn't fit, change it or else keep it.
1917B-> Second operation is only needed at first instance, as other strings can be reached 
by just the first operation after that. Thus we check the string from the end,

vector<int> nxt(26, n);
    ans[n - 1] = 1;
    nxt[s[n - 1] - 'a'] = n - 1;

    for (int i = n - 2; i >= 0; i--) {
        ans[i] = ans[i + 1] + (nxt[s[i] - 'a'] - i);
        nxt[s[i] - 'a'] = i;
    }

    cout << ans[0] << endl;

And use dp to add the answer for subsequent 
1891B-> almost did it, the only optimization was just doing it if it is minimum encountered thus far.