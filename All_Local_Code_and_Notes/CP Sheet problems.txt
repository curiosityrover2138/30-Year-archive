1849 B-> Sort it using mod of k, and the indexes divisible by k will go first, then k-1, k-2, etc 
and among them the ones with lesser ones will go first. Use stable_sort for that.
1831B-> Find the maximum continguous sequence of each element in the array and the left and right pointers
for it, that way you can 
1765M-> Just go through all the divisors in O(sqrt(n)) and find the first divisor that will be the answer
1715B-> Greedy with k*b as first and 
1438B-> If any 2 values are same it will always be possible 
1447 B-> If the negative numbers are odd, we just take the minmum value and subtract it from sum twice. 
Else the sum is the answer.
1704B-> Use a greedy strategy starting from first element, if it doesn't fit, change it or else keep it.
1917B-> Second operation is only needed at first instance, as other strings can be reached 
by just the first operation after that. Thus we check the string from the end,

vector<int> nxt(26, n);
    ans[n - 1] = 1;
    nxt[s[n - 1] - 'a'] = n - 1;

    for (int i = n - 2; i >= 0; i--) {
        ans[i] = ans[i + 1] + (nxt[s[i] - 'a'] - i);
        nxt[s[i] - 'a'] = i;
    }

    cout << ans[0] << endl;

And use dp to add the answer for subsequent 
1891B-> almost did it, the only optimization was just doing it if it is minimum encountered thus far.
1731B-> Use mod_inverse using fermat's little theorem for dividing

ull mod_inverse(ull a, ull m) {
    ull result = 1;
    ull exp = m - 2; // Fermat's Little Theorem
    while (exp > 0) {
        if (exp % 2 == 1) {
            result = (result * a) % m;
        }
        a = (a * a) % m;
        exp /= 2;
    }
    return result;
}

void solve() {
    ull n;
    cin >> n;

    ull inv6 = mod_inverse(6, MOD);

    ull ans = ((n * (n + 1) % MOD) * ((2 * n + 1) % MOD) % MOD) * inv6 % MOD;

    ans = (ans * 2) % MOD;

    ans = (ans - (n * (n + 1) / 2) % MOD + MOD) % MOD; // To keep it positive

    ans = (ans * 2022) % MOD;

    cout << ans << endl;

}

1820 B 

1793C Use a 2 pointer approach.

1742 E 

int n, q;
    cin >> n >> q;
    vector<long long> pref;
    pref.push_back(0);
    vector<int> prefmax;
    for(int i = 0; i < n; i++)
    {
        int x;
        cin >> x;
        pref.push_back(pref.back()+x);
        if(i == 0)
        {
            prefmax.push_back(x);
        }
        else
        {
            prefmax.push_back(max(prefmax.back(), x));
        }
    }
    for(int i = 0; i < q; i++)
    {
        int k;
        cin >> k;
        int ind = upper_bound(prefmax.begin(), prefmax.end(), k)-prefmax.begin();
        cout << pref[ind] << " ";
    }
    cout << endl;

    Using binary search and prefix sum

https://codeforces.com/problemset/problem/1881/D

https://codeforces.com/problemset/problem/1857/D

https://codeforces.com/problemset/problem/1775/B


https://codeforces.com/problemset/problem/1676/G

Dynamic programming problem + tree 
Run dynamic programming from the leaves to the root. For each vertex store the values of the number of balanced
subtrees as well as the number of black and white vertices in it 
Then from a vertex we can count the total number of white vertices in its subtree as well as black vertices in its 
subtree and update the total if these 2 numbers are equal. The answer is the answer at the root 

int n;
	cin >> n;
	vector<int> child[n + 7];
	for (int i = 2; i <= n; i++) {
		int x;
		cin >> x;
		child[x].push_back(i);
	}
	string s;
	cin >> s;
	int res = 0;
	function<int(int)> dp = [&] (int x) {
		int bal = (s[x - 1] == 'B') ? -1 : 1;
		if (child[x].empty()) {return bal;}
		for (int i : child[x]) {
			bal += dp(i);
		}
		if (bal == 0) {res++;}
		return bal;
	};
	dp(1);
	cout << res << '\n';


https://codeforces.com/problemset/problem/1669/H

Greedily take bits 
int n, k; cin >> n >> k;
        vector<int> cnt(31, 0), a(n);
        for(int i = 0;i < n; ++i) {
            cin >> a[i];
            for(int j = 30; j >= 0; --j) {
                if(a[i] & (1 << j)) ++cnt[j];
            }
        }
        int ans = 0;
        for(int i = 30; i >= 0; --i) {
            int need = n - cnt[i];
            if(need <= k) {
                k -= need;
                ans += (1 << i);
            }
        }
        cout << ans << "\n";


https://codeforces.com/problemset/problem/1601/A

Think of bit problems and and or problems more in terms of array of bits 


https://codeforces.com/contest/1498/problem/B

Take the count of all widths, now try and fit the maximum width of the rectangle possible. If its not possible, 
reset the width and increment height by 1 and try again.

int n, box_width, w;
        cin >> n >> box_width;

        vector<int> counts(20);
        for (int i = 0; i < n; i++) {
            cin >> w;
            counts[log2(w)]++;
        }

        int height = 1, space_left = box_width;

        for (int iter = 0; iter < n; iter++) {
            int largest = -1;

            for (int size = 19; size >= 0; size--) {
                if (counts[size] and (1 << size) <= space_left) {
                    largest = size;
                    break;
                }
            }

            if (largest == -1) {
                space_left = box_width;
                height++;
                for (int size = 19; size >= 0; size--) {
                    if (counts[size] and (1 << size) <= space_left) {
                        largest = size;
                        break;
                    }
                }
            }

            counts[largest] -= 1;
            space_left -= 1 << largest;
        }

        cout << height << endl;


https://codeforces.com/problemset/problem/1459/B

Formula based approach. THink of how the values are dependent on n being odd or even

https://codeforces.com/problemset/problem/1366/B