Move on after completing 80% of a level. Then do the rest 20% while doing the next till 80%

https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/G

Simple idea but I overcomplicated it. Just check the total and see if mid*k is less than or equal or not.
Basically we add to the total the minimum of vec[i] or mid as we cannot add more than mid but we can always 
keep adding and if the total is fine we can distribute easily 

Print number

Floating point is tricky, I was doing the same thing but taking left<right and final==c 
both give errors in floating point. Everything else was correct. Also needed to ensure that 
answer is printed so at the end print left if ans is unchanged. I was printing in the loop which 
meant for some cases the answer wasn't printed

long double c;
    cin>>c;

    long double left=0,right=c;
    long double ans=-1;
    while(right-left>1e-7){
        long double middle=left+(right-left)/2;
        long double square = middle*middle;
        long double square_root = sqrt(middle);
        long double final = square+square_root;
        if(abs(final-c)<=1e-6){
        
            ans=middle;
            break;
        }
        else if(final>c){
            right=middle;
        }
        else{
            left=middle;
        }
    }
    if(ans==-1) ans=left;
    cout<<fixed<<setprecision(6)<<ans;



Rope cutting problem https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/B:

Basically make left and right equal and check for difference in precision since we are dealing with real numbers 
and not integers 

ll n,k;
    cin>>n>>k;
    long double left=0,right=10000000;
    vector<long double> vec(n,0);
    for(int i=0;i<n;i++){
        cin>>vec[i];
    }
    long double ans=0;
    while((right-left)>1e-7){
        long double rope_length=left+(right-left)/2;
        ll count=0;
        for(auto itr: vec){
            count+=((ll)(itr/rope_length));
        }
        if(count>=k){
            ans=max(ans,rope_length);
            left=rope_length;
        }
        else{
            right=rope_length;
        }
    }
    cout<<fixed<<setprecision(6)<<ans;



https://codeforces.com/gym/104114/problem/N

Just a 2 pass would have worked. I was trying a prefix sum kind of approach after getting confused 
by the module. But the reason it doesnt work is we want local maximas and not global ones 

https://usaco.org/index.php?page=viewproblem2&cpid=416

Run a transformation on the original grid to make the diamond into a square

https://atcoder.jp/contests/abc125/tasks/abc125_c

Use a prefix and suffix to find the gcd of all but one

https://www.spoj.com/problems/HAYBALE/

Very common trick. Increment the lower half of the range and decrement 1 greater than the upper half 
and then take prefix sum to find the actual array 

https://usaco.org/index.php?page=viewproblem2&cpid=916
Didn't even understand howt his was graphs. Instead of thinking in a graphs manner should have Tried 
just doing it like adhoc

https://usaco.org/index.php?page=viewproblem2&cpid=689#

Had this vague idea of trying the same thing from end, but didn't do it for some reason
Very easy at the end, but guess I got distracted 


https://dmoj.ca/problem/ccc08s4

Check all the pairs. Take the rest in a vector, and then use all 4 operations, and put it in that vector 
and recursively go and backtrack to check different ones.

void dfsAllParentheses(vector<int> vec, int &maxim) {
    if (vec.size() == 1) {
        if (vec[0] <= 24) maxim = max(maxim, vec[0]);
        return;
    }
    int n = vec.size();
    for (int i = 0; i < n; ++i) {
        for (int j = i+1; j < n; ++j) {
            vector<int> nextVec;
            for (int k = 0; k < n; ++k) {
                if (k != i && k != j) nextVec.push_back(vec[k]);
            }

            int a = vec[i], b = vec[j];

            nextVec.push_back(a + b);
            dfsAllParentheses(nextVec, maxim);
            nextVec.pop_back();

            nextVec.push_back(a - b);
            dfsAllParentheses(nextVec, maxim);
            nextVec.pop_back();

            nextVec.push_back(b - a);
            dfsAllParentheses(nextVec, maxim);
            nextVec.pop_back();

            nextVec.push_back(a * b);
            dfsAllParentheses(nextVec, maxim);
            nextVec.pop_back();

            if (b != 0 && a % b == 0) {
                nextVec.push_back(a / b);
                dfsAllParentheses(nextVec, maxim);
                nextVec.pop_back();
            }

            if (a != 0 && b % a == 0) {
                nextVec.push_back(b / a);
                dfsAllParentheses(nextVec, maxim);
                nextVec.pop_back();
            }
        }
    }
}



Back Forth:

recursively go through each barn and at the end input in the set.

void recursively_go(int day, vector<int> barn1, vector<int> barn2, int curr_barn_one, set<int> &total_possibilities);
If I don't use this line, basically here go_to_barn uses recursively_go and recursively_go uses go_to_barn
so any function I put above the other function will give undefined error. So one of them needs to be defined 
at the top like this. This is called a forward declaration.

Code:
void recursively_go(int day, vector<int> barn1, vector<int> barn2, int curr_barn_one, set<int> &total_possibilities);

void go_to_barn(vector<int> barn1, vector<int> barn2, int target_barn, int ind, int curr_barn_one, set<int> &total_possibilities, int day) {
    if (target_barn == 2) {
        int tmp = barn1[ind];
        curr_barn_one -= tmp;
        barn1.erase(barn1.begin() + ind);
        barn2.push_back(tmp);
        recursively_go(day + 1, barn1, barn2, curr_barn_one, total_possibilities);
    } else if (target_barn == 1) {
        int tmp = barn2[ind];
        curr_barn_one += tmp;
        barn2.erase(barn2.begin() + ind);
        barn1.push_back(tmp);
        recursively_go(day + 1, barn1, barn2, curr_barn_one, total_possibilities);
    }
}

void recursively_go(int day, vector<int> barn1, vector<int> barn2, int curr_barn_one, set<int> &total_possibilities) {
    if (day == 5) {
        //Insert after everything is done, earlier I was trying to insert and delete as we went 
        // but that won't work as set size will keep varying and numbers will become invalid in recursive calls
        total_possibilities.insert(curr_barn_one);
        return;
    }
    if (day == 1 || day == 3) {
        for (int i = 0; i < barn1.size(); i++) {
            go_to_barn(barn1, barn2, 2, i, curr_barn_one, total_possibilities, day);
        }
    } else if (day == 2 || day == 4) {
        for (int i = 0; i < barn2.size(); i++) {
            go_to_barn(barn1, barn2, 1, i, curr_barn_one, total_possibilities, day);
        }
    }
}






Livestock Lineup:

    Generating from next_permutation 

    sort(vec.begin(),vec.end());

    do{
        //Check if the permutation satisfies the conditions
    }while(next_permutation(vec.begin(),vec.end()));





Air Cownditioning:

    Very frequently used trick of generating bitmasks and then for all possibilities choosing if it is valid

    for(int mask=0;mask<(1<<n);mask++){
        for(int i=0;i<n;i++){
            if(mask & (1<<i)){
                //Select this and do something here
            }
        }
    }





https://usaco.org/index.php?page=viewproblem2&cpid=832

Basically try for all indexes where 1st cow can be and seeing if that leads to a valid solution


(pref_sum[i]%n+n)%n trick for negative values in pref_sum and ensuring the mod is always correct

If I do abs(pref_sum[i])%n it becomes a different "class" of modulo due to 6-1 and 6- (-1) behaving differently so 1 has modulo 
1 and -1 has modulo 

https://codeforces.com/contest/863/problem/B

Brute force all the ones not selected, then just find pairs from the ones selected. The 1st-2nd, 3rd-4th 
will work because we are finding the ones selected, so 1st-4th + 2nd-3rd == 1st-2nd + 3rd-4th


https://usaco.org/index.php?page=viewproblem2&cpid=667

Should have used pair of strings, as each city name can repeat with multiple states
and using string,string mapping overrides that


https://codeforces.com/contest/1209/problem/G1

I didn't understand this solution totally but it was intuitive. Basically for any stretch 
we try reducing everything based on the occurance of other elements. Its fine because 
it was the last of the topic. So I will complete bronze when I am atleast 60% done with silver.